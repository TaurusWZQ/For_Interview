# **面试问题总结**



## 语言类

### 语言特点与其他语言比较

#### 简述下C++语言的特点

**参考回答**

1. C++在C语言基础上引入了**面对对象**的机制，同时也**兼容C语言**。
2. C++有三大特性（1）封装。（2）继承。（3）多态；
3. C++语言编写出的程序结构清晰、易于扩充，程序**可读性好**。
4. C++生成的代码**质量高**，运行**效率高**，仅比汇编语言慢10%～20%；
5. C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等；
6. C++**可复用性**高，C++引入了**模板**的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）。
7. 同时，C++是**不断在发展**的语言。C++后续版本更是发展了不少新特性，如C++11中引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。



#### 说说C语言和C++的区别

**参考回答**

1. C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多**新特性**，如引用、智能指针、auto变量等。
2. C++是**面对对象**的编程语言；C语言是**面对过程**的编程语言。
3. C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来**改善安全性**，如const常量、引用、cast转换、智能指针、try—catch等等；
4. C++**可复用性**高，C++引入了**模板**的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库**更灵活、更通用**。



#### 说说 C++中 struct 和 class 的区别

**参考回答**

1. struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；

2. struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的。

   ```c++
   struct A{
       int iNum;    // 默认访问控制权限是 public
   }
   class B{
       int iNum;    // 默认访问控制权限是 private
   }
   ```

3. 在继承关系中，struct 默认是公有继承，而 class 是私有继承；

4. class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数。

   ```c++
   template<typename T, typename Y>    // 可以把typename 换成 class 
   int Func(const T& t, const Y& y) { 
       //TODO 
   }
   ```

   

#### 说说C++结构体和C结构体的区别

**参考回答**

区别：

（1）C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。

（2）C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。

（3）C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。

（4）C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。

**C++ 中的 struct 是对 C 中的 struct 进行了扩充，**

它们在声明时的区别如下:

|          |           C            | C++                      |
| :------: | :--------------------: | ------------------------ |
| 成员函数 |         不能有         | 可以                     |
| 静态成员 |         不能有         | 可以                     |
| 访问控制 |  默认public，不能修改  | public/private/protected |
| 继承关系 |       不可以继承       | 可从类或者其他结构体继承 |
|  初始化  | 不能直接初始化数据成员 | 可以                     |

使用时的区别：

C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用

```c++
struct Student{
    int  iAgeNum;
    string strName;
}
typedef struct Student Student2;    //C中取别名

struct Student stu1;    // C 中正常使用
Student2 stu2;            // C 中通过取别名的使用
Student stu3;            // C++ 中使用
```



#### 说说include头文件的顺序以及双引号""和尖括号<>的区别

**参考回答**

1. 区别：

   （1）尖括号<>的头文件是**系统文件**，双引号""的头文件是**自定义文件**。

   （2）编译器预处理阶段查找头文件的路径不一样。

2. 查找路径：

   （1）使用尖括号<>的头文件的查找路径：编译器设置的头文件路径-->系统变量。

   （2）使用双引号""的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。



#### 导入C函数的关键字是什么，C++编译时和C有什么不同？

**参考回答**

1. **关键字：**在C++中，导入C函数的关键字是**extern**，表达形式为**extern “C”**， extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按**C语言**的进行编译，而不是C++的。
2. **编译区别：**由于C++支持函数重载，因此编译器编译函数的过程中会将函数的**参数类型**也加到编译后的代码中，而不仅仅是**函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括**函数名**。

```c++
//extern示例
//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译
extern "C" int strcmp(const char *s1, const char *s2);

//在C++程序里边声明该函数
extern "C"{
    #include <string.h>//string.h里边包含了要调用的C函数的声明
}

//两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__
```



#### 简述C++从代码到可执行二进制文件的过程

**参考回答**

 C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，**预编译、编译、汇编、链接**。

**答案解析**

1. 预编译：这个过程主要的处理操作如下：

   （1） 将所有的#define删除，并且展开所有的宏定义

   （2） 处理所有的条件预编译指令，如#if、#ifdef

   （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。

   （4） 过滤所有的注释

   （5） 添加行号和文件名标识。

2. 编译：这个过程主要的处理操作如下：

   （1） 词法分析：将源代码的字符序列分割成一系列的记号。

   （2） 语法分析：对记号进行语法分析，产生语法树。

   （3） 语义分析：判断表达式是否有意义。

   （4） 代码优化：

   （5） 目标代码生成：生成汇编代码。

   （6） 目标代码优化：

3. 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。

4. 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

   链接分为静态链接和动态链接。

   静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。

   而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。



#### 说说 static关键字的作用

**参考回答**

1. **定义全局静态变量和局部静态变量**：在变量前面加上static关键字。初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；

2. **定义静态函数**：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在**本源文件**中使用；

3. 在变量类型前加上static关键字，变量即被定义为静态变量。**静态变量只能在本源文件中使用**；

   ```c++
   //示例
   static int a;
   static void func();
   ```

4. 在c++中，**static关键字可以用于定义类中的静态成员变量**：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都**共享**这一块静态存储空间。

5. 在c++中，**static关键字可以用于定义类中的静态成员函数**：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都**共享**这一块静态存储空间。

**答案解析**

当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。



#### 说说静态变量什么时候初始化？

**参考回答**

对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。

而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。

**答案解析**

1. **作用域**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。

   静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。

   静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。

   类静态成员变量：类作用域。

2. **所在空间**：都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。

3. **生命周期**：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存。



#### Struct 和 Union 区别



1.在存储多个成员信息时，编译器会自动给struct每个成员分配存储空间，struct 可以存储多个成员信息，而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息。

2.都是由多个不同的数据类型成员组成，但在任何同一时刻，Union只存放了一个被先选中的成员，而结构体的所有成员都存在。

3.对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于struct 的不同成员赋值 是互不影响的。



struct 简单来说就是一些相互关联的元素的集合，说是集合，其实它们在内存中的存放是有先后顺序的，并且每个元素都有自己的内存空间。按照声明的变量顺序来存放。

union 的不同之处就在于，它所有的元素共享同一内存单元，且分配给union的内存size 由类型最大的元素 size 来确定。既然是内存共享，理所当然地，它不能同时存放多个成员的值，而只能存放其中的一个值，就是最后赋予它的值。在union的使用中，如果给其中某个成员赋值，然后使用另一个成员，是未定义行为，后果自负。

复合数据类型，如union，struct，class的对齐方式为成员中对齐方式最大的成员的对齐方式。





**Big Three**

#### 说说构造函数有几种，分别什么作用











### 指针



#### 智能指针 smart pointer

**智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。**

**智能指针和普通指针的区别**在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。



标准库提供的这两种智能指针的区别在 于管理底层指针的方式：**shared_ptr** 允许多个指针指向同一个对象；**unique_ptr** 则“独占”所指向的对象。

标准库还定义了一个名为 **weak_ptr** 的伴随类，它是一种弱引用，指向 **shared_ptr** 所管理的对象。三种类型都定义在memory头文件中。



![shared-ptr](../assets/blog_res/面试问题总结.assets/shared-ptr.png)





#### 函数指针

**说说什么是函数指针，如何定义函数指针，有什么使用场景**











### C++11 新特性



#### 说说 C++11 的新特性有哪些

**参考回答**

 C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：

1. 语法的改进

   （1）统一的初始化方法

   （2）成员变量默认初始化

   （3）auto关键字 用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）

   （4）decltype 求表达式的类型

   （5）智能指针 shared_ptr

   （6）空指针 nullptr（原来NULL）

   （7）基于范围的for循环

   （8）右值引用和move语义 让程序员有意识减少进行深拷贝操作

2. 标准库扩充（往STL里新加进一些模板类，比较好用）

   （9）无序容器（哈希表） 用法和功能同map一模一样，区别在于哈希表的效率更高

   （10）正则表达式 可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串

   （11）Lambda表达式

**答案解析**

1. 统一的初始化方法

    C++98/03 可以使用初始化列表（initializer list）进行初始化：

```c++
int i_arr[3] = { 1, 2, 3 };
long l_arr[] = { 1, 3, 2, 4 };
struct A
{
    int x;
    int y;
} a = { 1, 2 };
```

 **但是**这种初始化方式的**适用性非常狭窄**，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：

```c++
class Foo
{
public:
    Foo(int) {}
private:
    Foo(const Foo &);
};
int main(void)
{
    Foo a1(123);
    Foo a2 = 123;  //error: 'Foo::Foo(const Foo &)' is private
    Foo a3 = { 123 };
    Foo a4 { 123 };
    int a5 = { 3 };
    int a6 { 3 };
    return 0;
}
```

在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。



2.成员变量默认初始化

好处：构建一个类的对象不需要用构造函数初始化成员变量。

```c++
//程序实例
#include<iostream>
using namespace std;
class B
{
public:
    int m = 1234; //成员变量有一个初始值
    int n;
};
int main()
{
    B b;
    cout << b.m << endl;
    return 0;
}
```



3.auto关键字

 用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）。

```c++
//程序实例
#include <vector>
using namespace std;
int main(){
    vector< vector<int> > v;
    vector< vector<int> >::iterator i = v.begin();
    return 0;
}
```

 可以看出来，定义迭代器 i 的时候，类型书写比较冗长，容易出错。然而有了 auto 类型推导，我们大可不必这样，只写一个 auto 即可。



4.decltype 求表达式的类型

 decltype 是 [C++](http://c.biancheng.net/cplus/)11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。

(1)为什么要有decltype

 因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。

 auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：

```c++
auto varname = value;
decltype(exp) varname = value;
```

 其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。

 auto 根据"="右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟"="右边的 value 没有关系。

 另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：

```c++
decltype(exp) varname;
```

(2)代码示例

```c++
// decltype 用法举例
nt a = 0;
decltype(a) b = 1;  //b 被推导成了 int
decltype(10.8) x = 5.5;  //x 被推导成了 double
decltype(x + 100) y;  //y 被推导成了 double
```



5.智能指针 shared_ptr

 和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。

```c++
#include <iostream>
#include <memory>
using namespace std;
int main()
{
    //构建 2 个智能指针
    std::shared_ptr<int> p1(new int(10));
    std::shared_ptr<int> p2(p1);
    //输出 p2 指向的数据
    cout << *p2 << endl;
    p1.reset();//引用计数减 1,p1为空指针
    if (p1) {
        cout << "p1 不为空" << endl;
    }
    else {
        cout << "p1 为空" << endl;
    }
    //以上操作，并不会影响 p2
    cout << *p2 << endl;
    //判断当前和 p2 同指向的智能指针有多少个
    cout << p2.use_count() << endl;
    return 0;
}

/*    程序运行结果：        
            10
            p1 为空
            10
            1    
*/          
```



6.空指针 nullptr（原来NULL）

 nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。值得一提的是，nullptr 可以被隐式转换成任意的指针类型。例如：

```c++
int * a1 = nullptr;
char * a2 = nullptr;
double * a3 = nullptr;
```

 显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int*、char* 以及 double* 指针类型。另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：

```c++
#include <iostream>
using namespace std;
void isnull(void *c){
    cout << "void*c" << endl;
}
void isnull(int n){
    cout << "int n" << endl;
}
int main() {
    isnull(NULL);
    isnull(nullptr);
    return 0;
}

/*    程序运行结果：        
        int n
        void*c
*/          
```



7.基于范围的for循环









#### 可变参数模板 variadic template

一个可变参数模板（variadic template）就是一个接受可变数目参数的模板函数或模板类。

可变数目的参数被称为参数包（parameter packet）。















#### 智能指针 smart pointer

见指针-智能指针





#### 内联函数 inline function

将函数声明为inline，表示要求编译器在每个函数调用点上，将函数的内容展开。面对一个inline函数，编译器可将该函数的调用操作改为以一份函数代码副本代替。

只要在函数前面加上关键词inline，便可将该函数声明为inline

将函数指定为inline，只是对编译器提出的一种要求。编译器是否执行这项请求，需视编译器而定。

一般而言，最适合声明为inline的函数：体积小，常被调用，所从事的计算并不复杂。

inline函数的定义，常常被放在头文件中。由于编译器必须在它被调用的时候加以展开，所以这个时候其定义必须是有效的。



### 面向对象



#### 简述一下什么是面向对象

**参考回答**

1. 面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示

2. 面向过程和面向对象的区别

   面向过程：根据业务逻辑从上到下写代码

   面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程



#### 简述一下面向对象的三大特征

**参考回答**

面向对象的三大特征是封装、继承、多态。

1. 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通 道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。

2. 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

   三种继承方式

   |      继承方式       |   private继承   |   protected继承   |    public继承     |
   | :-----------------: | :-------------: | :---------------: | :---------------: |
   |  基类的private成员  |     不可见      |      不可见       |      不可见       |
   | 基类的protected成员 | 变为private成员 | 仍为protected成员 | 仍为protected成员 |
   |  基类的public成员   | 变为private成员 | 变为protected成员 |  仍为public成员   |

3. 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。







#### 简述一下 C++ 的重载和重写，以及它们的区别

**参考回答**

1. 重写

   是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

   示例如下：

```c++
#include<bits/stdc++.h>
using namespace std;

class A
{
public:
    virtual    void fun()
    {
        cout << "A";
    }
};
class B :public A
{
public:
    virtual void fun()
    {
        cout << "B";
    }
};
int main(void)
{
    A* a = new B();
    a->fun();//输出B，A类中的fun在B类中重写
}
```

2.重载

我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

```c++
#include<bits/stdc++.h>
using namespace std;
class A
{
    void fun() {};
    void fun(int i) {};
    void fun(int i, int j) {};
    void fun1(int i,int j){};
};
```



#### 说说 C++ 的重载和重写是如何实现的

**参考答案**

1. C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。







2.在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

1. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。
2. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
3. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。
4. 重写用虚函数来实现，结合动态绑定。
5. 纯虚函数是虚函数再加上 = 0。
6. 抽象类是指包括至少一个纯虚函数的类。

纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。





#### 说说 C 语言如何实现 C++ 语言中的重载

**参考答案**

c语言中不允许有同名函数，因为编译时函数命名是一样的，不像c++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：

1. 使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能
2. 重载函数使用可变参数，方式如打开文件open函数
3. gcc有内置函数，程序使用编译函数可以实现函数重载

示例如下：

```c++
#include<stdio.h>

void func_int(void * a)
{
    printf("%d\n",*(int*)a);  //输出int类型，注意 void * 转化为int
}

void func_double(void * b)
{
    printf("%.2f\n",*(double*)b);
}

typedef void (*ptr)(void *);  //typedef申明一个函数指针

void c_func(ptr p,void *param)
{
     p(param);                //调用对应函数
}

int main()
{
    int a = 23;
    double b = 23.23;
    c_func(func_int,&a);
    c_func(func_double,&b);
    return 0;
}
```





#### 说说构造函数有几种，分别什么作用



**参考答案**

C++中的构造函数可以分为4类：默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。

默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。

```c++
class Student
{
public:
    //默认构造函数
    Student()
    {
       num=1001;
       age=18;       
    }
    //初始化构造函数
    Student(int n,int a):num(n),age(a){}
private:
    int num;
    int age;
};
int main()
{
    //用默认构造函数初始化对象S1
    Student s1;
    //用初始化构造函数初始化对象S2
    Student s2(1002,18);
    return 0;
}
```

**有了有参的构造了，编译器就不提供默认的构造函数。**

拷贝构造函数

```c++
#include "stdafx.h"
#include "iostream.h"

class Test
{
    int i;
    int *p;
public:
    Test(int ai,int value)
    {
        i = ai;
        p = new int(value);
    }
    ~Test()
    {
        delete p;
    }
    Test(const Test& t)
    {
        this->i = t.i;
        this->p = new int(*t.p);
    }
};
//复制构造函数用于复制本类的对象
int main(int argc, char* argv[])
{
    Test t1(1,2);
    Test t2(t1);//将对象t1复制给t2。注意复制和赋值的概念不同
    return 0;
}
```

**拷贝构造函数默认实现的是值拷贝（浅拷贝）。**

移动构造函数。用于将其他类型的变量，隐式转换为本类对象。下面的转换构造函数，将int类型的r转换为Student类型的对象，对象的age为r，num为1004.

```c++
 Student(int r)
 ｛
     int num=1004；
     int age= r；

  ｝
```





#### 只定义析构函数，会自动生成哪些构造函数

**参考答案**

只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。

默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。



#### 说说一个类，默认会生成哪些函数

**参考答案**

定义一个空类

```c++
Empty()
{
}
```

默认会生成以下几个函数

1. 无参的构造函数

   在定义类的对象的时候，完成对象的初始化工作。

```c++
Empty()
{
}
```

2.拷贝构造函数

​	拷贝构造函数用于复制本类的对象

```c++
Empty(const Empty& copy)
{
}
```

 3.赋值运算符

```c++
Empty& operator = (const Empty& copy)
{
}
```

4.析构函数（非虚）

```c++
~Empty()
{
}
```







### STL



#### 请说说 STL 的基本组成部分

标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。

**广义上讲**，STL分为3类：Algorithm（算法）、Container（容器）和Iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。

**详细的说**，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。

标准模板库STL主要由6大组成部分：

1. 容器(Container)

    是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。

2. 算法（Algorithm）

    是用来操作容器中的数据的模板函数。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。

3. 迭代器（Iterator）

    提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象;

4. 仿函数（Function object）

    仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。

5. 适配器（Adaptor）

    简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。

6. 空间配制器（Allocator）

    为STL提供空间配置的系统。其中主要工作包括两部分：

   （1）对象的创建与销毁；

   （2）内存的获取与释放。







#### 请说说 STL 中常见的容器，并介绍一下实现原理

**参考回答**

 容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：

1. 顺序容器

    容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：

   （1）vector 头文件

    动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。

   （2）deque 头文件

    双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。

   （3）list 头文件

    双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。

2. 关联式容器

    元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：

   （1）set/multiset 头文件

    set 即集合。set中不允许相同元素，multiset中允许存在相同元素。

   （2）map/multimap 头文件

    map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素。

    **注意：**map同multimap的不同在于是否允许相同first值的元素。

3. 容器适配器

    封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue，具体实现原理如下：

   （1）stack 头文件

    栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。后进先出。

   （2）queue 头文件

    队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。

   （3）priority_queue 头文件

    优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。





#### 说说 STL 中 map hashtable deque list 的实现原理

**参考回答**

 map、hashtable、deque、list实现机理分别为红黑树、函数映射、双向队列、双向链表，他们的特性分别如下：

1. map实现原理

    map内部实现了一个**红黑树**（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。

2. hashtable（也称散列表，直译作哈希表）实现原理

    hashtable采用了**函数映射的思想**记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。

3. deque实现原理

    deque内部实现的是一个**双向队列**。元素在内存连续存放。随机存取任何元素都在常数时间完成（仅次于vector）。所有适用于vector的操作都适用于deque。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。

4. list实现原理

    list内部实现的是一个**双向链表**。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。无成员函数，给定一个下标i，访问第i个元素的内容，只能从头部挨个遍历到第i个元素。





#### 请你来介绍一下 STL 的空间配置器（allocator）

**参考回答**

 一般情况下,一个程序包括数据结构和相应的算法，而数据结构作为存储数据的组织形式，与内存空间有着密切的联系。在C++ STL中，空间配置器便是用来实现内存空间(一般是内存，也可以是硬盘等空间)分配的工具，他与容器联系紧密，每一种容器的空间分配都是通过空间分配器alloctor实现的。

**答案解析**

1. 两种C++类对象实例化方式的异同

    在c++中，创建类对象一般分为两种方式：一种是直接利用构造函数,直接构造类对象，如 Test test()；另一种是通过new来实例化一个类对象，如 Test *pTest = new Test；那么，这两种方式有什么异同点呢？

   我们知道，内存分配主要有三种方式：

   （1） 静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行空间内都存在。如全局变量,静态变量等。

   （2） 栈空间分配：程序在运行期间，函数内的局部变量通过栈空间来分配存储（函数调用栈），当函数执行完毕返回时，相对应的栈空间被立即回收。主要是局部变量。
   （3）堆空间分配：程序在运行期间，通过在堆空间上为数据分配存储空间，通过malloc和new创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过free()或者是delete()函数对堆空间进行释放，否则会造成内存溢出。

   那么，从**内存空间分配的角度**来对这两种方式的区别，就比较容易区分:

   （1）对于第一种方式来说，是直接通过调用Test类的构造函数来实例化Test类对象的,如果该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间。
   （2）对于第二种方式来说,就显得比较复杂。这里主要以new类对象来说明一下。new一个类对象,其实是执行了两步操作：首先,调用new在堆空间分配内存,然后调用类的构造函数构造对象的内容；同样，使用delete释放时，也是经历了两个步骤：首先调用类的析构函数释放类对象，然后调用delete释放堆空间。

2. C++ STL空间配置器实现

    很容易想象，为了实现空间配置器，完全可以利用new和delete函数并对其进行封装实现STL的空间配置器，的确可以这样。但是，为了最大化提升效率，SGI STL版本并没有简单的这样做，而是采取了一定的措施，实现了更加高效复杂的空间分配策略。由于以上的构造都分为两部分，所以，在SGI STL中，将对象的构造切分开来，分成空间配置和对象构造两部分。

    内存配置操作: 通过alloc::allocate()实现
   ​ 内存释放操作: 通过alloc::deallocate()实现
   ​ 对象构造操作: 通过::construct()实现
   ​ 对象释放操作: 通过::destroy()实现

    关于内存空间的配置与释放，SGI STL采用了两级配置器：一级配置器主要是考虑大块内存空间，利用malloc和free实现；二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），采用链表free_list来维护内存池（memory pool），free_list通过union结构实现，空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。



#### STL 容器用过哪些，查找的时间复杂度是多少，为什么？



STL中常用的容器有vector、deque、list、map、set、multimap、multiset、unordered_map、unordered_set等。容器底层实现方式及时间复杂度分别如下：

1. vector

   采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为：

   插入: O(N)

   查看: O(1)

   删除: O(N)

2. deque

   采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为：

   插入: O(N)

   查看: O(1)

   删除: O(N)

3. list

   采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为：

   插入: O(1)

   查看: O(N)

   删除: O(1)

4. map、set、multimap、multiset

   上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:

   插入: O(logN)

   查看: O(logN)

   删除: O(logN)

5. unordered_map、unordered_set、unordered_multimap、 unordered_multiset

   上述四种容器采用哈希表实现，不同操作的时间复杂度为：
   插入: O(1)，最坏情况O(N)

   查看: O(1)，最坏情况O(N)

   删除: O(1)，最坏情况O(N)

   **注意：**容器的时间复杂度取决于其底层实现方式。

















## 操作系统

### Linux



#### 说说常用的Linux命令

**参考回答**

1. cd命令：用于切换当前目录
2. ls命令：查看当前文件与目录
3. grep命令：该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工。
4. cp命令：复制命令
5. mv命令：移动文件或文件夹命令
6. rm命令：删除文件或文件夹命令
7. ps命令：查看进程情况
8. kill命令：向进程发送终止信号
9. tar命令：对文件进行打包，调用gzip或bzip对文件进行压缩或解压
10. cat命令：查看文件内容，与less、more功能相似
11. top命令：可以查看操作系统的信息，如进程、CPU占用率、内存信息等
12. pwd命令：命令用于显示工作目录。



#### 说说如何以root权限运行某个程序。

```c
sudo chown root app（文件名）
sudo chmod u+s app（文件名）
```









## 计算机网络









## 项目



TF-IDF（term frequency–inverse document frequency）是一种用于[信息检索](https://baike.baidu.com/item/信息检索/831904)与[数据挖掘](https://baike.baidu.com/item/数据挖掘/216477)的常用加权技术。TF是词频(Term Frequency)，IDF是逆文本频率指数(Inverse Document Frequency)。



TF-IDF是一种[统计方法](https://baike.baidu.com/item/统计方法)，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在[语料库](https://baike.baidu.com/item/语料库)中出现的频率成反比下降。

在一份给定的文件里，**词频**（term frequency，TF）指的是某一个给定的词语在该文件中出现的频率。这个数字是对**词数**(term count)的归一化，以防止它偏向长的文件。（同一个词语在长文件里可能会比短文件有更高的词数，而不管该词语重要与否。）对于在某一特定文件里的词语来说，它的重要性可表示为：

以上式子中分子是该词在文件中的出现次数，而分母则是在文件中所有字词的出现次数之和。

[![img](../assets/blog_res/面试问题总结.assets/format,f_auto.png)](https://baike.baidu.com/pic/tf-idf/8816134/0/4afbfbedab64034f258b7c13a2c379310a551d64?fr=lemma&ct=single)

**逆向文件频率**（inverse document frequency，IDF）是一个词语普遍重要性的度量。某一特定词语的IDF，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取以10为底的[对数](https://baike.baidu.com/item/对数)得到



然后再计算TF与IDF的乘积。

某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于过滤掉常见的词语，保留重要的词语。







## 反问



1如果能够进入到贵公司，会有一些正式或者非正式的培训吗，就是说怎么让新的员工培训体系吧？
2刚进入贵公司，主要的职责和工作内容会是什么，未来发展情况，大概是怎么样员工考核机制的？
3在这个职位方向上，团队的大概情况，开发项目的流程大概是怎么样的？
4贵公司对这项职务的期待的目标（需要哪些必备的技能），或者说有什么部分我可以更加努力的地方？
5薪资结构组成，基本工资、绩效、年终奖、公积金缴纳比例和缴纳基数
6基于招聘需求中希望技能反问（我看岗位需要理解各种电机各种控制算法，那未来工作会需要做各种电机控制吗，还是只做PMSM）
嗯，好我想了解的大概就这些了，不好意思占用了面试官们的宝贵时间，谢谢，谢谢你们！
